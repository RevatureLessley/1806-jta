JavaScript
----------
-interpreted runtime language
-supported in most browsers by default.
-originally called mocha -> livescript -> JavaScript for marketing
-built in 10 days and shipped with netscape

clear() clears the console.
Datatypes: string, number, boolean, function, object, undefined
1/0 is infinity and 1/-0 is -infinity.
null is an object but is not typeof nor instanceof Object.
undefined means a variable without a value. 
undefined == null <- true. == compares values.
undefined === null <- false. === compares values and datatypes.
JavaScript does type coercion.
false == "false" <- false.
Boolean logic works like in C.
"bobbert" * 3 is NaN, which is typeof number.
\ is the escape character.
[] denotes arrays. {} denotes objects.
x = []; x.push(value). Arrays does not have typing. Indexes could be anything, including Infinity, NaN, null.
console.log() is standard output.
x.pop() gets the last index that is a Number.
x.unshift() gets the first index that is a Number.
x.splice(Number i, Number j, Object o) insertas o at i, destroying j following elements.
x.sort() sorts indexes like strings. x.sort(Function) sorts by Function.
JavaScript objects are key-value pairs.
obj.field and obj[field] accesses a field of an object.

JavaScript is built on ECMAscript. We are currently on version ES8.
JavaScript variables have global, function, lexical scopes.
If you don't use var for variable declarations then it defaults to global. Using var can keep variables in function scope.
ES6 introduced const and let, which makes constants and lexical scoping.
Lexical scoping uses curly braces. consts are automatically lexical scope.

var x = 5;
function foo() {
	var y = 10;
	for(var i = 0: i < y; i++) {
		var z = 5;
	}
	console.log(x + y + z);		//prints 20
}

let x = 5;
function foo() {
	let y = 10;
	for(let i = 0: i < y; i++) {
		let z = 5;
	}
	console.log(x + y + z);		//ReferenceError
}

JavaScript does variable hoisting which hoists all declarations to the top of their scope.

JavaScript cannot save files or interact with servers.

6 Errors
--------
ReferenceError
SyntaxError
EvalError - deprecated
URIError
RangeError
TypeError

Self-invoking function: var foo = (function definition)(); <- var foo = <function definition>; foo = foo();

Invoking new on a function creates a constructor.

JavaScript follows prototypal inheritance. Every object inherits from Prototype.

object.prototype accesses the prototype which acts like a static variable.

Callback functions 
-take function definitions as parameters
-functions can then be executed within a parent function after an asynchronous event